# Hotel Reservation System ‚Äì AEP Projekt (FS2025)

## üßæ Projektbeschreibung

Dieses Projekt wurde im Rahmen des Moduls *Anwendungsentwicklung mit Python* (AEP, FS2025) an der Hochschule f√ºr Wirtschaft FHNW umgesetzt.  
Ziel ist die exemplarische Implementierung eines Hotelreservierungssystems unter Einsatz moderner Python-Technologien, modularer Softwarearchitektur und relationaler Datenhaltung.

Das Projekt wurde vollst√§ndig mit PyCharm umgesetzt, inkl. Versionsverwaltung √ºber GitHub. Eine Deepnote-Integration wurde nicht verwendet
> **Abstract:**  
Diese Arbeit demonstriert, wie sich reale Gesch√§ftsprozesse ‚Äì dargestellt durch User Stories ‚Äì systematisch in Codestrukturen √ºberf√ºhren lassen. Zum Einsatz kommen objektorientierte Programmierung, relationale Datenbanken (SQLite), Schichtentrennung (N-Tier Architektur) sowie Tools zur Visualisierung und PDF-Ausgabe.

üé• [Hier klicken, um unsere Projektpr√§sentation anzusehen](https://link-zu-eurem-video)

> In diesem Video demonstrieren wir unsere L√∂sung wie in einer Live-Pr√§sentation.  
> Wir zeigen exemplarisch zwei ausgew√§hlte User Stories, die wir besonders gelungen finden, und erkl√§ren dabei jeweils die dahinterliegende Logik und den Code.  
> Zudem erl√§utern wir abwechselnd verschiedene Aspekte des Projekts, insbesondere unsere jeweiligen Beitr√§ge.  
> Beide Teammitglieder sind in der Pr√§sentation zu sehen.

---

## üë§ Rollen

### üë©‚Äçüíª Daliah Beck  
**Rolle: Architektur, Datenmodellierung, Datenzugriff, Gesch√§ftslogik, Dokumentation**

Daliah war verantwortlich f√ºr die technische Grundlage und den Aufbau des Hotelreservierungssystems. Ihr Fokus lag auf der initialen Projektstruktur, der Implementierung der Datenmodelle, dem Datenbankzugriff, zentraler Gesch√§ftslogik sowie der vollst√§ndigen schriftlichen Dokumentation.

**Beitr√§ge (basierend auf Commit-Verlauf):**

- **Projektsetup & Infrastruktur:**
  - Initialisierung des Repositories (`initial commit`, `.gitignore`, `requirements.txt`, Ordnerstruktur)
  - Einbindung und Organisation der SQLite-Datenbanken (`working_db.db`, `Script.sql`)
  - Git-Konfiguration f√ºr sauberen Workflow


- **Modellierung & Datenstruktur:**
  - Erstellung aller Model-Klassen (`Guest`, `Hotel`, `Room`, `Booking`, `Invoice`, `Facility`, `RoomType`)
  - Einbindung von Beziehungen entsprechend dem UML-Diagramm (inkl. Komposition/Aggregation)


- **Data Access & SQL:**
  - Entwicklung und Strukturierung s√§mtlicher `*_data_access.py`-Dateien
  - Zentrale SQL-Abfragen und Hilfsfunktionen in `SQL.py`
  - Verarbeitung hotel- und zimmerbezogener Daten √ºber strukturierte SQL-Logik


- **Business Logic Layer:**
  - Aufbau der Gesch√§ftslogik-Komponenten:
    - `invoice_manager.py`
    - `booking_manager.py`
    - `room_manager.py`
    - `room_type_manager.py`
  - Implementierung erweiterter Abl√§ufe wie Rechnungslogik, Validierungen, Datenroutinen
  - User Story 5 & 6 


- **Zus√§tzliche Features & Utility:**
  - Implementierung von `email_sender.py` zur optionalen Buchungsbest√§tigung per E-Mail
  - Anpassung und Strukturpflege der Utility-Funktionen (`utils/`)


- **Fehlerbehandlung & Konfliktl√∂sung:**
  - Commit am **26.05.2025**: L√∂sung von Merge-Konflikten und Integration von Hotfixes
  - Verbesserung der Abfragen f√ºr spezifische Hotels und Zimmerzuordnung


- **Dokumentation:**
  - Verfasserin der **README.md-Dokumentation**


### üë© Katharina Hagen  
**Rolle: User Stories, UI/UX, Testing, Versionskontrolle, CLI-Interaktion**

Katharina war f√ºr die iterative Entwicklung der User Stories, die Gestaltung der Benutzerf√ºhrung sowie f√ºr Eingabelogik, Testing und Repository-Pflege zust√§ndig. Sie arbeitete kontinuierlich an der Verbesserung der funktionalen Abl√§ufe und sorgte f√ºr eine konsistente Ausf√ºhrung der Anforderungen in der CLI.

**Beitr√§ge (basierend auf Commit-Verlauf):**

- **User Stories (konzeptionell und technisch):**
  - Umsetzung, √úberarbeitung und Verbesserung von:
    - **User Story 1‚Äì4** (Hotels anzeigen, filtern, Zimmerdetails, Buchung)
    - **√úberarbeitung User Story 5 & 6** 
      ‚Üí *siehe Commit ‚Äûuserstory 5 und 6 verbessert‚Äú am 08.06.2025 ‚Äì 18:48*
    - **User Story 7 & 8** (dynamische Preise, Buchungs√ºbersicht)
    - **User Story 9 & 10** (Admin-Reports & Datenpflege)
    - √úberarbeitung von **User Story 3** (08.06.2025 ‚Äì 22:59)
  - Korrektur und Feinschliff von Eingabelogik & Datenabfragen im Rahmen dieser Stories


- **UI- & CLI-Interaktion:**
  - Gestaltung der Benutzerf√ºhrung im CLI
  - Eingabevalidierung & Fehlerbehandlung √ºber `Inputs.py` und eigene Utils
  - Umsetzung und Verkn√ºpfung der Eingabefl√ºsse mit Business-Logik


- **Testing & Konfliktl√∂sung:**
  - Wiederholtes Refactoring, Testing und Reviews w√§hrend der Story-Phasen
  - Pflege des konsistenten Codes zwischen Modellierung, Datenzugriff und Logik
  - Merge-Koordination & Konfliktl√∂sungen mit Pull Requests


- **Technische Unterst√ºtzung:**
  - Erweiterung von `sql.py` mit spezifischen Abfragen (z.‚ÄØB. Zimmerfilter)
  - Unterst√ºtzung bei der Modellintegration & Datenbankabgleich (`model: guest, hotel, room` etc.)

### Pr√§sentation und Coaching

- **Tutorials / Demo** ‚Äì Daliah Beck, Katharina Hagen  
- **Coaches (extern)** ‚Äì Charuta Pande, Phillip Gachnang

---

## üõ†Ô∏è Tools & Technologien

- **Python 3.10+** ‚Äì Hauptsprache der Applikation
- **SQLite** ‚Äì lokale relationale Datenbank
- **pandas** ‚Äì Verarbeitung tabellarischer Daten (z.‚ÄØB. Rechnungsdetails, G√§steauswertung)
- **matplotlib** ‚Äì visuelle Darstellung (z.‚ÄØB. Zimmerauslastung, Umsatztrend)
- **fpdf** ‚Äì Erzeugung von PDF-Buchungsbest√§tigungen
- **Jupyter Notebook** ‚Äì explorative Datenanalyse und Funktionsdemos
- **Visual Paradigm** ‚Äì UML-Klassendiagramm (Designphase)

---

## üß† Verwendete Konzepte & Python-Prinzipien

In der Umsetzung unseres Hotelreservierungssystems haben wir gezielt auf sauberen, wartbaren und idiomatischen Python-Code geachtet. Dabei kamen zahlreiche zentrale Programmierkonzepte und -prinzipien zum Einsatz, die wir im Folgenden strukturiert darstellen:

### ‚úÖ Funktionen & Strukturprinzipien

- **Funktionen mit und ohne R√ºckgabewert**  
  Zentrale Logik wurde √ºber modularisierte Funktionen umgesetzt:  
  z.‚ÄØB. `create_guest()`, `cancel_booking()`, `validate_city()` (in `guest_manager.py`, `validation_functions.py`).


- **Parameter & Default Values**  
  ‚Üí `search_hotel_print_rooms(city, check_in_date=None, ...)` erlaubt flexible Funktionsaufrufe mit optionalen Parametern.


- **KISS & DRY-Prinzipien**  
  ‚Üí Die **Validierungslogik** wurde in einer eigenen `validation_functions.py` ausgelagert.  
  ‚Üí Durch zentrale Managerklassen und Utility-Methoden vermeiden wir Wiederholungen und halten den Code klar und verst√§ndlich.

---

### ‚úÖ Kontrollstrukturen

- **if/elif-Logik**  
  ‚Üí H√§ufig verwendet z.‚ÄØB. in der Benutzerf√ºhrung (`if buchung == "nein": ... elif ...`)  
  ‚Üí Besonders prominent in `main.py` und CLI-Men√ºs.


- **Loops (for)**  
  ‚Üí Iteration √ºber Hotels, Zimmer und Buchungen (z.‚ÄØB. `for h in hotels:`).  
  ‚Üí Einsatz z.‚ÄØB. in `hotel_manager.py`, `booking_manager.py`.

---

### ‚úÖ Datenstrukturen & Typen

- **Listen & Dictionaries**  
  ‚Üí Hotel-Listen, Buchungs√ºbersichten etc. werden als `list[Hotel]`, `dict` strukturiert gef√ºhrt.  
  ‚Üí `hotels_dict[hotel_id] = hotel` ‚Äì f√ºr schnelles Mapping.


- **Tuples & R√ºckgabewerte**  
  ‚Üí Verwendung von `(check_in, check_out)` als strukturierte R√ºckgabewerte.


- **List Comprehension**  
  ‚Üí z.‚ÄØB. `active_bookings = [b for b in bookings if not b.is_cancelled]`

---

### ‚úÖ Objektorientierung & Architektur

- **Klassen & Objekte**  
  ‚Üí Umsetzung der zentralen Entit√§ten als OOP-Klassen (`Room`, `Hotel`, `Guest`, `Booking`, `Invoice`).


- **Kapselung & Data Hiding**  
  ‚Üí Zugriff √ºber Getter/Setter, interne Zust√§nde durch `__` und `_` gesch√ºtzt.  
  ‚Üí Z.‚ÄØB. `self._booking_da`, `self.__room_id`.


- **Vererbung & Polymorphismus**  
  ‚Üí `BookingDataAccess(BaseDataAccess)` erbt und √ºberschreibt Methoden (z.‚ÄØB. `fetchall()`).


- **Aggregation / Komposition / Assoziation**  
  ‚Üí `Hotel` aggregiert `Address`, `Room` kompositionell mit `RoomType`, `Booking` assoziiert `Guest` und `Room`.

---

### ‚úÖ Fehlerbehandlung

- **try/except-Bl√∂cke**  
  ‚Üí Robustheit durch saubere Fehlerbehandlung beim Datenbankzugriff, Input Parsing, Rechnungslogik.  
  ‚Üí Z.‚ÄØB. `ValueError`, `traceback.print_exc()` zur Nachvollziehbarkeit.

---

### ‚úÖ Datenzugriff & Datenbanklogik

- **SQLite-Integration**  
  ‚Üí Alle CRUD-Operationen in `*_data_access.py` √ºber `sqlite3`.  
  ‚Üí Strukturierte Queries in `booking_data_access.py`, `hotel_data_access.py`.


- **Kontextmanagement & File Handling**  
  ‚Üí `shutil.copyfile(...)` zur DB-Initialisierung, `with`-Kontext f√ºr Datenbankverbindungen.

---

### ‚úÖ Visualisierung & Analyse

- **Pandas**  
  ‚Üí Tabellenanzeige im Admin-Modul, z.‚ÄØB. Buchungs√ºbersichten.


- **Matplotlib (User Story 9 & 10)**  
  ‚Üí Diagramme f√ºr Zimmertyp-Nutzung und Umsatztrends.

---

### üîé Fazit: Codequalit√§t & Prinzipientreue

Unser Projekt orientiert sich bewusst an **Best Practices der Softwareentwicklung**. Besonders hervorzuheben:

- **DRY (Don't Repeat Yourself)**  
  ‚Üí Wiederverwendbare Managerklassen und Validierungslogik.


- **KISS (Keep It Simple, Stupid)**  
  ‚Üí Klare Methoden mit Einzelverantwortung, keine √ºberkomplizierten Abh√§ngigkeiten.


- **Saubere Trennung der Ebenen**  
  ‚Üí `model/`, `data_access/`, `business_logic/`, `ui/` ‚Äì konsequent strukturiert.

> Damit demonstriert das Projekt nicht nur die Umsetzung der geforderten Funktionalit√§ten, sondern auch ein solides Verst√§ndnis moderner Python-Entwicklung im Sinne der Clean Code Prinzipien.

---

## ‚úÖ Validierung als architektonisches Prinzip ‚Äì Rolle der `validation_functions.py`

Ein zentrales Qualit√§tsmerkmal unseres Systems ist die **systematische Entkopplung von Validierungslogik und fachlicher Gesch√§ftsverarbeitung**. Dieser Anspruch manifestiert sich exemplarisch in der Datei `validation_functions.py`, die als zentrale Anlaufstelle f√ºr alle Eingabevalidierungen dient. Die Auslagerung in ein dediziertes Modul folgt nicht nur dem Prinzip der Wiederverwendbarkeit, sondern optimiert Wartbarkeit, Lesbarkeit und Fehlertoleranz im gesamten Codebestand.

### üîç Vorteile auf Systemebene

| Vorteil                           | Beschreibung |
|----------------------------------|--------------|
| **Wiederverwendbarkeit**         | Funktionen wie `validate_guest_data()` oder `parse_and_validate_dates()` sind universell einsetzbar ‚Äì z.‚ÄØB. in `BookingManager`, `GuestManager` oder UI-Komponenten. |
| **Reduktion von Redundanz (DRY)**| Durch Zentralisierung werden doppelte Validierungslogiken vermieden und die Koh√§renz √ºber Module hinweg gew√§hrleistet. |
| **Saubere Trennung (Separation of Concerns)** | Die Gesch√§ftslogik bleibt schlank, da Pr√ºfungen nicht in Manager- oder UI-Schichten eingebettet sind. |
| **Fehlertoleranz & Debugging**   | Einheitlich strukturierte Fehlerausgaben (z.‚ÄØB. `ValueError`) erleichtern Identifikation und Behebung von Nutzungsfehlern. |
| **Konsistente Nutzerf√ºhrung**    | Benutzer erhalten standardisierte, verst√§ndliche R√ºckmeldungen ‚Äì unabh√§ngig davon, wo die Eingabe erfolgte. |

### üß† Eingesetzte Programmierkonzepte

Die Architektur der Validierungslogik basiert auf bew√§hrten Prinzipien moderner Softwareentwicklung:

- **Funktionen mit/ohne R√ºckgabewert**:  
  Beispiel: `validate_name()` pr√ºft ausschliesslich, w√§hrend `normalize_city()` einen bereinigten String zur√ºckliefert.


- **Typisierte R√ºckgaben & Tuples**:  
  `parse_and_validate_dates(...) ‚Üí tuple[date, date]` erh√∂ht die Lesbarkeit und Typensicherheit.


- **Fehlerbehandlung via `try/except`**:  
  Fehlerhafte Benutzereingaben l√∂sen gezielte `ValueError`-Ausnahmen aus, die im Manager oder der UI-Schicht kontrolliert behandelt werden.


- **Kapselung & Modularit√§t**:  
  Die Validierungen sind bewusst au√üerhalb der UI- und Logikebenen platziert, wodurch eine hohe Wiederverwendbarkeit und Austauschbarkeit gew√§hrleistet ist.


- **KISS-Prinzip (Keep It Simple, Stupid)**:  
  Jede Funktion erf√ºllt exakt eine klar abgegrenzte Aufgabe ‚Äì z.‚ÄØB. nur Datum validieren oder PLZ pr√ºfen ‚Äì und folgt dabei einer schlanken Methodensignatur.


- **Defensive Programmierung**:  
  Durch fr√ºhzeitige Abfangmechanismen wird sichergestellt, dass fehlerhafte Eingaben das System nicht in instabile Zust√§nde bringen.


- **Testbarkeit & Dokumentierbarkeit**:  
  Die klar benannten Funktionen erm√∂glichen zielgerichtetes Unit-Testing und tragen zu einem dokumentierten, nachvollziehbaren Codebase bei.

![img_3.png](img_3.png)
![img_5.png](img_5.png)
> **Abstract:** 
> Die Datei `validation_functions.py` stellt damit nicht nur ein technisches Hilfsmittel dar, sondern verk√∂rpert in ihrer Struktur und Funktion ein Schl√ºsselelement guter Softwarearchitektur: Sie unterst√ºtzt ein robustes, testbares und skalierbares Systemdesign ‚Äì ganz im Sinne moderner Python-Entwicklung und professioneller Codequalit√§t.

---

## üß† Architektur (N-Tier Modell)

Die Applikation folgt einer **mehrschichtigen Architektur (N-Tier)** zur logischen Trennung und besseren Wartbarkeit. Diese umfasst:

### 1. `database/`  
SQLite-Datenbanken + SQL-Skripte zur Strukturdefinition und Initialbef√ºllung.

### 2. `model/`  
Objektorientierte Repr√§sentation aller Entit√§ten (`Hotel`, `Room`, `Guest`, `Booking`, ‚Ä¶) mit klaren Attributen, Methoden und Konstruktoren.

### 3. `data_access/`  
Jede Klasse k√ºmmert sich um eine Entit√§t (z.‚ÄØB. `booking_data_access.py`), f√ºhrt SQL-Operationen aus und basiert auf einer gemeinsamen `base_data_access.py`.

### 4. `business_logic/`  
Implementiert Gesch√§ftsregeln, Validierungen und komplexe Abl√§ufe wie die Rechnungserstellung (`invoice_manager.py`) oder Zimmerverf√ºgbarkeitspr√ºfung.

### 5. `ui/` und `utils/`  
- `ui/`: Eingabepr√ºfung und Konsoleninteraktion (CLI)
- `utils/`: PDF-Export, E-Mail-Versand, SQL-Hilfen

### 6. Root-Level  
- `main.py`: Einstiegspunkt der Anwendung (CLI)
- `Hotelreservation.ipynb`: Notebook zur Analyse & Visualisierung
- `requirements.txt`, `README.md`, `.gitignore`, `LICENSE`

---

## üìê Klassendiagramm

Das Klassendiagramm zeigt die Beziehungen der zentralen Entit√§ten im System ‚Äì inklusive:

- **Komposition:** `Hotel` ‚Üí `Room`, `Guest` ‚Üí `Booking`
- **Aggregation:** `Room` ‚Üí `RoomType`, `Facility`
- **Assoziationen:** `Booking` ‚Üî `Invoice`

![img_1.png](img_1.png)

> Erstellt mit Visual Paradigm. Das Diagramm diente als Grundlage f√ºr die Implementierung aller modellbasierten Klassen.

---

## üìñ Anleitung zur Nutzung der Applikation (CLI)

### Voraussetzungen

- **Python 3.10 oder h√∂her**
- Lokale Entwicklungsumgebung (z.‚ÄØB. PyCharm oder VS Code)
- Abh√§ngigkeiten aus `requirements.txt` (sofern verwendet)

### 1. Projektstruktur vorbereiten

Stelle sicher, dass die Projektstruktur wie folgt vorhanden ist:

/Hotelreservationsystem

‚îú‚îÄ‚îÄ main.py

‚îú‚îÄ‚îÄ database/

‚îÇ ‚îî‚îÄ‚îÄ hotel_reservation_sample.db

‚îú‚îÄ‚îÄ data_access/

‚îú‚îÄ‚îÄ business_logic/

‚îú‚îÄ‚îÄ model/

‚îú‚îÄ‚îÄ utils/

‚îî‚îÄ‚îÄ ...

### 2. Virtuelle Umgebung (empfohlen)

```bash
python -m venv venv
source venv/bin/activate       # Windows: venv\Scripts\activate
pip install -r requirements.txt
```
### 3. Anwendung starten
Im Hauptverzeichnis:
```bash
python main.py
```
Daraufhin erscheint im Terminal:

HOTEL RESERVIERUNGSSYSTEM
1. Hotels in einer Stadt anzeigen
2. Verf√ºgbare Zimmer anzeigen
3. Zimmer buchen
4. Rechnung erstellen

### 4. M√∂gliche Aktionen im CLI

| Option | Beschreibung                                                                     |
| ------ | -------------------------------------------------------------------------------- |
| `1`    | Zeigt alle Hotels in einer bestimmten Stadt                                      |
| `2`    | Listet verf√ºgbare Zimmer in einem Hotel f√ºr ein bestimmtes Datum                 |
| `3`    | Bucht ein Zimmer f√ºr einen Gast (Eingabe von Gast-ID und Zimmer-ID erforderlich) |
| `4`    | Erstellt eine Rechnung f√ºr eine bestehende Buchung                               |

### 5. Erweiterte Funktionen (im Code enthalten, nicht direkt im Men√º)
Hotelverwaltung (Admin):

add_hotel(), update_hotel(), delete_hotel() direkt in main.py aufrufbar

Buchung stornieren:

cancel_booking(booking_id)

PDF-Buchungsbest√§tigung generieren:

create_booking_confirmation() aus utils/pdf_export.py

Bewertungen:

Tabelle Review wird automatisch erstellt, wenn main.py gestartet wird

### 6. Validierung
Alle Eingaben (z.‚ÄØB. Stadtname, Sterne, G√§stezahl) werden durch Funktionen in Inputs.py validiert. Ung√ºltige Eingaben l√∂sen ValueError mit passenden Meldungen aus.

> **Abstract:**  
> Hinweis: Es wird keine Notebook-Demo verwendet. Die gesamte Anwendung l√§uft √ºber eine strukturierte Kommandozeilenoberfl√§che (CLI) und ist vollst√§ndig mit Python und SQLite implementiert.

---

## üîç Annahmen & Interpretationen

- **Preiskalkulation:**  
  Der Preis pro Nacht wird direkt aus der Spalte `price_per_night` in der Tabelle `Room` √ºbernommen. Es gibt keine dynamische oder saisonale Preisgestaltung. Der Gesamtbetrag (`total_amount`) ergibt sich durch Multiplikation mit der Anzahl N√§chte.


- **Rechnungserstellung:**  
  Eine Rechnung (`Invoice`) wird immer genau einer Buchung (`Booking`) zugeordnet. Der Ausstellungszeitpunkt erfolgt automatisch √ºber `CURRENT_TIMESTAMP`.


- **Stornierungslogik:**  
  Eine Buchung kann nur storniert werden, wenn das Check-In-Datum in der Zukunft liegt. Stornierte Buchungen (Feld `is_cancelled`) verursachen standardm√§√üig **keine Kosten**, au√üer es ist eine Stornogeb√ºhr definiert (optional √ºber Logik im `BookingManager`).


- **Bewertungen:**  
  Bewertungen werden √ºber die Tabelle `Review` verwaltet. Es wird angenommen, dass **ein Gast pro Hotel genau eine Bewertung** abgeben kann.


- **Eingabevalidierung:**  
  Alle Benutzereingaben (Stadt, Sterne, G√§stezahl) werden √ºber dedizierte Funktionen validiert. St√§dte au√üerhalb der vordefinierten Liste (`Z√ºrich`, `Luzern`, `Bern`, `Gen√®ve`, `Basel`) sind nicht zul√§ssig.


- **Pro Buchung nur ein Zimmer:**  
  Eine Buchung bezieht sich immer auf ein einzelnes Zimmer (1:1 Beziehung). F√ºr mehrere Zimmer m√ºssen mehrere Buchungen erstellt werden.


- **Keine Authentifizierung:**  
  Es gibt keine Login-/Rollenverwaltung. Admin-Funktionen (Hotelpflege, PDF-Export, Stornierung) sind im Code direkt aufrufbar und daher nicht zugriffsgesch√ºtzt.


- **Demo-Daten:**  
  Alle Daten (Hotels, G√§ste, Zimmer etc.) wurden aus der mitgelieferten `working_db.db` initial geladen. Diese Daten dienen Test- und Demonstrationszwecken.

> Diese Annahmen wurden bewusst getroffen, um den Fokus auf Gesch√§ftslogik, Datenbankanbindung und funktionale Umsetzung gem√§√ü den AEP-Vorgaben zu legen.

---



## üí° Hervorzuhebende Codebeispiele

Im Rahmen der Umsetzung verschiedener User Stories wurden eine Reihe technischer L√∂sungen implementiert, die besonders hervorzuheben sind:

### üîç 1. Dynamische Hotel- und Zimmerfilter (User Story 1.5)

Hotels k√∂nnen anhand einer Kombination aus Stadt, Zeitraum, Sternebewertung und G√§steanzahl gesucht werden. Die Kombination dieser Parameter f√ºhrt zu einer pr√§zisen Verf√ºgbarkeitssuche:

```python
hotels = hotel_da.search_hotel_combinated(
    city=city_input,
    check_in_date=check_in,
    check_out_date=check_out,
    min_stars=min_stars,
    max_guests=guest_count
)
```
### üßæ 2. Preisberechnung & Rechnungserstellung (User Story 5)
dsfa
Die Rechnung wird basierend auf dem Zimmerpreis pro Nacht und der Aufenthaltsdauer erstellt und automatisch mit einem Zeitstempel versehen:

```python
total_amount = room.price_per_night * nights
invoice = invoice_da.create_new_invoice(
    booking=booking,
    total_amount=total_amount,
    issue_date=issue_date
)
```
### ‚ùå 3. Stornierung mit automatischer Rechnungskorrektur (User Story 6)

Bereits fakturierte Buchungen k√∂nnen storniert und auf null gesetzt werden ‚Äì inklusive Pr√ºfung, ob bereits eine Stornierung erfolgt ist:

```python
if booking.is_cancelled:
    print("Diese Buchung wurde bereits storniert.")
else:
    success = booking_mgr.cancel_booking_by_id(booking_id)
    invoice_da.update_invoice_total(invoice["invoice_id"], 0.00)
```

### üìä 4. Datenvisualisierung: Beliebteste Zimmertypen (User Story 9)

Mit pandas und matplotlib wurde ein Balkendiagramm zur Darstellung der gebuchten Zimmertypen erstellt:

```python
query = """
SELECT rt.description AS room_type, COUNT(*) AS total_bookings
FROM Booking b
JOIN Room r ON b.room_id = r.room_id
JOIN Room_Type rt ON r.type_id = rt.type_id
WHERE b.is_cancelled = 0
GROUP BY rt.description
"""
df = pd.read_sql_query(query, conn)
df.plot(kind="bar", x="room_type", y="total_bookings")
```

### üìà 5. Umsatzanalyse nach Monaten (User Story 10)

Der monatliche Umsatz wird √ºber SQL extrahiert und als Liniendiagramm visualisiert:

```python
query = """
SELECT strftime('%Y-%m', check_in_date) AS month, SUM(total_amount) AS revenue
FROM Booking
WHERE is_cancelled = 0
GROUP BY month
"""
df = pd.read_sql_query(query, conn)
df.plot(kind="line", x="month", y="revenue", marker='o')
```
> **Abstract:**  
Diese Codebeispiele stehen exemplarisch f√ºr die Verbindung aus datenbankzentrierter Logik, robuster Gesch√§ftsverarbeitung und benutzerfreundlicher Darstellung.

---

## üìã Dokumentation ausgew√§hlter User Stories

### üßæ User Story 5 ‚Äì Interaktive Rechnungserstellung im Notebook

Diese Komponente erm√∂glicht es dem Benutzer, basierend auf einer Buchungs-ID, eine Rechnung direkt im Jupyter Notebook zu generieren und als strukturiertes HTML-Dokument darzustellen. Die Implementierung folgt strikt dem Prinzip der Trennung von Verantwortlichkeiten (*Separation of Concerns*), um Lesbarkeit, Wartbarkeit und Wiederverwendbarkeit zu maximieren.

#### Ablauf:

- **Eingabe:**  
  Eine g√ºltige `booking_id` wird vom Benutzer √ºber ein interaktives Eingabefeld eingegeben.


- **Verarbeitung:**  
  - Die zugeh√∂rige Buchung wird √ºber den `BookingManager` geladen.  
  - Die Rechnung wird durch den `InvoiceManager` erstellt, einschliesslich automatischer Berechnung der Aufenthaltsdauer und Gesamtkosten.


- **Ausgabe:**  
  - Die gerenderte Rechnung wird im Notebook als `IPython.display.HTML`-Objekt angezeigt.
  - Felder wie Gastname, Datum, Preisstruktur und Gesamtbetrag sind visuell gegliedert und farblich hervorgehoben.


#### Technische Besonderheiten:

- **HTML-Ausgabe ausgelagert:**  
  Die Klasse `InvoiceRenderer` (in `utils/invoicerender.py`) kapselt die gesamte Pr√§sentationslogik.

  
- **OOP-Prinzipien:**  
  - **Kapselung:** Manager-Klassen f√ºr Booking, Invoice, Guest und Room  
  - **Aggregation:** Invoice ‚Üí Booking ‚Üí Guest, Room  
  - **Modularit√§t:** Die Funktion `display_invoice(invoice)` kann universell wiederverwendet werden.


- **Fehlerbehandlung:**  
  S√§mtliche Laufzeitfehler (z.‚ÄØB. ung√ºltige ID) werden mittels `try-except` abgefangen und benutzerfreundlich ausgegeben.

![img_2.png](img_2.png)
---

### üè® User Story 4.2 ‚Äì Buchung als unbekannter Gast (CLI)

Dieser interaktive Ablauf verkn√ºpft mehrere Komponenten des Systems zu einem durchg√§ngigen Prozess, der es G√§sten erm√∂glicht, ohne vorherige Registrierung ein Hotelzimmer zu buchen.

#### Prozesslogik:

- **Hotelsuche:**  
  Auswahl nach Stadt und Sternebewertung, Anzeige via `pandas.DataFrame`.


- **Hotelauswahl:**  
  Anzeige verf√ºgbarer Zimmer, deren IDs und Preise.


- **Buchung:**  
  - Eingabe von Zimmer-ID, Check-in/out-Daten und Gastinformationen  
  - Validierung aller Eingaben  
  - Erstellung eines `Booking`-Eintrags inkl. Berechnung des Gesamtpreises


- **Ausgabe:**  
  Best√§tigung inklusive Buchungsnummer und Details wird im Terminal ausgegeben.

#### Technische Umsetzung:

- **Fehlerresistenz:**  
  Umfassende Validierung und `try-except`-Block sichern Stabilit√§t.


- **OOP-basierte Architektur:**  
  Verwendete Manager: `HotelManager`, `RoomManager`, `BookingManager`, `GuestManager`


- **Datenbankzugriff:**  
  Gekapselt √ºber dedizierte Data Access Layer mit SQLite


- **CLI-Integration:**  
  Nahtlose Benutzerf√ºhrung und Eingabelogik √ºber `input()`-Sequenzen

---

### üßÆ User Story 10 ‚Äì Stammdatenpflege via Widget-Dashboard

Diese Komponente bildet ein Admin-Dashboard im Notebook, das die zentrale Pflege von Stammdaten erlaubt. √úber `ipywidgets` lassen sich √Ñnderungen an Zimmertypen, Preisen und Einrichtungen interaktiv durchf√ºhren.

#### Moduleigenschaften:

- **Anzeige:**  
  - `show_all_bookings()` zeigt alle Buchungen tabellarisch  
  - `show_rooms_with_facilities()` listet Zimmer samt Ausstattung


- **Interaktive Verwaltung:**  
  Eingabefelder f√ºr:
  - Zimmertyp (ID, Beschreibung, max. G√§ste)
  - Einrichtungen (ID, neuer Name)
  - Preis (Zimmer-ID, neuer Preis)

#### Technischer Aufbau:

- **Trennung von Logik & UI:**  
  - Datenlogik liegt vollst√§ndig in den jeweiligen `*_Manager`-Klassen  
  - GUI-Funktionen bleiben schlank und fokussiert


- **OOP & Python-Konzepte:**  
  - R√ºckgabewerte mit Typannotationen  
  - Datenkapselung √ºber Manager-Klassen  
  - DRY-Prinzip durch zentrale Steuerung  
  - Fehlerbehandlung per `try-except` in jedem Callback


#### Benutzerfreundlichkeit:

- √Ñnderungen sind sofort wirksam und direkt sichtbar  
- Nutzerf√ºhrung erfolgt vollst√§ndig innerhalb des Notebooks  
- Ausgaben und Fehlermeldungen werden im `Output()`-Widget angezeigt

---

## üß† Reflexion

Zu Beginn des Projekts waren wir urspr√ºnglich zu dritt in einer Gruppe. Nachdem sich die Gruppenkonstellation ge√§ndert hatte, haben wir (Daliah Beck und Katharina Hagen) das Projekt als Zweierteam eigenst√§ndig neu aufgesetzt ‚Äì mit dem klaren Ziel, eine robuste und vollst√§ndig funktionsf√§hige L√∂sung f√ºr ein Hotelreservierungssystem zu entwickeln.

Anstatt auf bestehende Strukturen zur√ºckzugreifen, haben wir uns bewusst daf√ºr entschieden, das Projekt komplett neu zu starten. Dadurch konnten wir alle zentralen Komponenten ‚Äì von der Architektur √ºber die Datenbank bis hin zur Business-Logik und den User Stories ‚Äì selbst gestalten und tiefgehend verstehen. Diese Herangehensweise hat unser Verst√§ndnis f√ºr die einzelnen Schichten eines Softwaresystems deutlich gest√§rkt.

Auch wenn der verf√ºgbare Zeitrahmen durch den sp√§ten Neustart naturgem√§ss enger war, haben wir diese Herausforderung als Chance genutzt: Wir haben uns schnell organisiert, klare Verantwortlichkeiten definiert und uns auf ein strukturiertes Vorgehen konzentriert. Gerade in dieser intensiven Phase konnten wir unsere F√§higkeiten in Planung, technischer Umsetzung und Zusammenarbeit besonders weiterentwickeln.

Besonders wertvoll war dabei die konsequente Trennung von Verantwortlichkeiten in unserer N-Tier-Architektur. Das Projekt erm√∂glichte uns, theoretisches Wissen direkt in die Praxis zu √ºberf√ºhren: Wir haben relationales Datenbankdesign mit SQL umgesetzt, datengetriebene Python-Module gebaut, Validierung und Fehlerbehandlung strukturiert integriert, und analytische Visualisierungen mit `pandas` und `matplotlib` realisiert.

Die Tatsache, dass wir die volle Kontrolle √ºber alle Komponenten hatten, erlaubte es uns, technische Entscheidungen mit Verst√§ndnis und Absicht zu treffen ‚Äì von der Modellierung bis hin zur CLI-Interaktion. Besonders stolz sind wir darauf, dass wir s√§mtliche Minimal-User-Stories erfolgreich umsetzen konnten, einschliesslich erweiterter Funktionen wie PDF-Export, Bewertungslogik und dynamischer Preisberechnung.

Insgesamt blicken wir auf ein Projekt zur√ºck, das nicht nur unsere technischen F√§higkeiten weiterentwickelt hat, sondern uns auch gezeigt hat, wie effektiv kollaboratives Arbeiten in einem strukturierten, selbstgesteuerten Rahmen sein kann. Die Entscheidung, alles eigenst√§ndig zu erarbeiten, hat uns nicht nur gefordert, sondern vor allem best√§rkt ‚Äì in unserer Kompetenz, in unserer Klarheit und in unserem Vertrauen in l√∂sungsorientiertes Software-Engineering.
